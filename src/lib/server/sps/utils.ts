import { type PathOrFileDescriptor, readdirSync, statSync } from "fs";
import type { Comment, Section, Sections, KV } from "./types";
import path from "path";
import type { DeviceConfig } from "./sps";


export const searchForFile = (dir: string, filename: string): PathOrFileDescriptor | undefined => {
    // read the contents of the directory
    const files = readdirSync(dir);
    // search through the files
    for (const file of files) {
        // build the full path of the file
        const filePath = path.join(dir, file);

        // get the file stats
        const fileStat = statSync(filePath);

        // if the file is a directory, recursively search the directory
        if (fileStat.isDirectory()) {
            return searchForFile(filePath, filename);
        } else if (!file.endsWith(filename)) {
            continue;
        } else {
            // if the file is a match, print it
            console.log(filePath);
            return (filePath as PathOrFileDescriptor);
        }
    } // fs.readFileSync(filePath)
}

/**
    * CommentWriter determines where the comment marker should be placed, along with it's style:
    *
    *  ### Styles:
    *          - CppStyle: `//`
    *          - CStyle:  `see below`
    *          - ScriptStyle: `#`
    *
    * @param c interface Comment, an object resembling the Comment toward a Section | KV
    * @param isKV boolean, `default = false`, helps identify if a KeyValue pair, within a Section should be commented.
    * @returns string, the `libconfig` formatted string for said comment
*/
const CommentWriter = (c: Comment, isKV: boolean = false):string => {
    switch (c.$style) {
        case "CppStyle": //? '//'
        if(isKV === true && c._isCommented) {
            return '// '
        } else if (isKV) return '';
        return c._description.map((line) => '// '+line).join('\n');
        case "CStyle": //? '/* */'
        if(isKV === true && c._isCommented) {
            return '/* '
        } else if (isKV) return '';
        if (c._description.length > 1) {
            return '/*\n ' + c._description.join('\n') + ' */';
        } else {
            return '/* ' + c._description.join('') + ' */';
        }
        case "ScriptStyle": //? '#'
        if(isKV === true && c._isCommented) {
            return '# '
        } else if (isKV) return '';
        return c._description.map((line) => '# '+line).join('\n');
    }
    return ''
}

/**
    * UpdateFields
    * @param dc DeviceConfig, the DeviceConfig generated by a Device class.
    * @param sections Sections, the sections of the `Shairport-Sync` configuration for the device
    * @param secName optional `string`, the top-level name of the section to be updated (helper)
    * @returns Sections, an updated PropertyMap 
    */
export const UpdateFields = (dc: DeviceConfig, sections: Sections, secName?: string):Sections => {
    let d = Object.entries(dc);
    return Object.fromEntries(Object.entries<Section>(sections) //.fromEntries(Object.entries(sections)
        .filter(([n,_]) => secName == n || secName === undefined )
        .map(([sectionName, val]) => {
            console.debug('in', sectionName);
            const section = Object(val);
            d = d.map(([seg, nVal]) => {
                if (section.hasOwnProperty(seg) && nVal !== undefined) {
                    console.debug(`section: ${sectionName} contains: ${seg}`);
                    const kval = section[seg] as KV;
                    kval._value = nVal;
                    return [seg, undefined];
                }
                return [seg, nVal];
            });
            return [sectionName, section];
    }));
}

// export type SectionPropertyName = keyof SectionProperty;
/**
    * SectionsWriter takes a Sections interfaced JSON object to be written into something parsable 
    *  by `shairport-sync`. i.e. `libconfig` format.
    * @param s Sections, a top-level view of sections to be written as `libconfig`
    * @returns string
    */
export const SectionsWriter = (s: Sections) => Object.entries<Section>(s).map(val => SectionWriter(...val)).join('');

/**
    * SectionWriter is similar to SectionsWriter, in which a Section (of JSON or JavaScript Object) is written to `.conf`
    * @param name string, name of the top-level section in `shairport-sync` configuration
    * @param s object | Section, an object that resembles a Section
    * @returns string in `libconfig` format of section
    */
export const SectionWriter = (name: String, s: object | Section) => {
    let children = new Map<string, KV>();
    const props = Object.entries(s) // .filter((elem) => { elem[0] !== '_comments' })
            // console.info(childs)
    for (let [key, value] of props) {
        if (key == '_comments') {
            continue
        }
        // console.log(key, value);
        children = children.set(key, (value as KV))
    }
    return CommentWriter((s as Section)._comments) + `${name} = {\n` + Array.from(children.entries()).map(([name, kv]) => {
        return CommentWriter(kv._description, true) + name + ' = ' + KvWriter(kv);
    }).join('\n') + '\n}\n';
}

/**
    * KvWriter writes out the value of a KeyValue-pair within a Section
    * @param kv KV, interface of the value linked to it's `key` (string) within a Section
    * @returns string relative to the KeyValue's `libconfig` format
    */
const KvWriter = (kv: KV) => {
    return kv._value + '; ' + CommentWriter(kv._description);
}